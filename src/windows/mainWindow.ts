import { app, BrowserWindow, ipcMain } from "electron";

import windowManager, { MainWindowManager } from "./windowManager";
import { getMetadata } from "../services/store";
// import FilePress from "../services/filepress";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

class MainWindow implements MainWindowManager {
  private window: Electron.BrowserWindow | null = null;
  filePress: any = null; //new FilePress();

  private createWindow() {
    this.window = new BrowserWindow({
      // x: bounds.width - 500,
      // y: bounds.height - 900,
      height: 700,
      width: 1024,
      frame: false,
      // transparent: true,
      resizable: false,
      fullscreenable: false,
      visualEffectState: "active",
      vibrancy: "sidebar",
      backgroundMaterial: "mica",
      titleBarStyle: "hiddenInset",
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
    });
    this.window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    this.window.webContents.openDevTools({ mode: "detach" });
    this.window.on("closed", () => {
      this.window = null;
    });
    const metadata = getMetadata();
    metadata.windowState && this.pinWindow();

    ipcMain.handle("pin-window", () => {
      this.pinWindow();
    });
    ipcMain.handle("minimize-window", () => {
      this.minimizeWindow();
    });
    ipcMain.handle("close-window", () => {
      this.close();
    });

    // Listen for job start request from renderer process
    ipcMain.handle(
      "process-files",
      async (event, commands: any[], metadata: any) => {
        // Store listeners to clean them up later
        const listeners = new Map();
        const jobIds: string[] = [];
        try {
          // Process each command and collect job IDs
          jobIds.push(
            ...commands.map((command) =>
              this.filePress.addCommandString(command.command, metadata)
            )
          );

          // Define progress listener and store it for cleanup
          const progressListener = (progress: any) => {
            // Only forward progress for jobs that were created in this request
            if (jobIds.includes(progress.jobId)) {
              event.sender.send("compression-progress", progress);
            }
          };

          // Define error listener and store it for cleanup
          const errorListener = (error: any) => {
            // Only forward errors for jobs that were created in this request
            if (jobIds.includes(error.jobId)) {
              console.error("File processing error:", error);
              event.sender.send("compression-error", {
                message: error.error?.message || error.error || "Unknown error",
                jobId: error.jobId,
              });
            }
          };

          // Define completion listener and store it for cleanup
          const completionListener = (completed: any) => {
            // Only forward completion for jobs that were created in this request
            if (jobIds.includes(completed.jobId)) {
              event.sender.send("compression-complete", completed);
            }
          };

          // Define all-completed listener for when all jobs finish
          const allCompletedListener = (summary: any) => {
            // Check if all our jobs are done before sending final summary
            if (
              jobIds.every((id) => {
                const job = this.filePress.getJobById(id);
                return !job || !this.filePress.isJobActive(id);
              })
            ) {
              event.sender.send("all-compressions-complete", {
                jobIds,
                totalSizeSaved: summary.totalSizeSaved,
              });
              // Clean up listeners when all jobs are complete
              cleanupListeners();
            }
          };

          // Store listeners for cleanup
          listeners.set("progress", progressListener);
          listeners.set("error", errorListener);
          listeners.set("completed", completionListener);
          listeners.set("allCompleted", allCompletedListener);

          // Attach listeners
          this.filePress.on("progress", progressListener);
          this.filePress.on("error", errorListener);
          this.filePress.on("completed", completionListener);
          this.filePress.on("allCompleted", allCompletedListener);

          // Function to clean up listeners when done
          const cleanupListeners = () => {
            listeners.forEach((listener, event) => {
              this.filePress.removeListener(event, listener);
            });
            listeners.clear();
          };

          // Clean up listeners if the window is closed
          event.sender.on("destroyed", cleanupListeners);

          console.log(
            `Started processing ${jobIds.length} files with job IDs:`,
            jobIds
          );

          return {
            jobIds,
            // queueStatus: this.filePress.getQueueStatus(),
          };
        } catch (error) {
          console.error("Error starting file processing:", error);

          // Clean up any listeners if there was an error
          listeners.forEach((listener, event) => {
            this.filePress.removeListener(event, listener);
          });

          throw error; // Rethrow to be handled by IPC
        }
      }
    );

    // Add a handler for cancelling jobs
    // ipcMain.handle("cancel-compression", async (event, jobId) => {
    //   const result = this.filePress.cancelJob(jobId);
    //   return { success: result };
    // });

    // Add a handler for cancelling all jobs
    // ipcMain.handle("cancel-all-compressions", async (event) => {
    //   this.filePress.cancelAllJobs();
    //   return { success: true };
    // });

    // Add a handler for getting queue status
    // ipcMain.handle("get-compression-queue-status", async () => {
    //   return this.filePress.getQueueStatus();
    // });
  }
  minimizeWindow() {
    this.window?.minimize();
  }
  pinWindow() {
    if (this.window?.isAlwaysOnTop()) {
      if (app.dock) app.dock.show();
      this.window?.setAlwaysOnTop(false);
      this.window?.setVisibleOnAllWorkspaces(false);
      // this.window?.setHiddenInMissionControl(false);
    } else {
      if (app.dock) app.dock.hide();
      this.window?.setAlwaysOnTop(true, "floating");
      this.window?.setVisibleOnAllWorkspaces(true, {
        visibleOnFullScreen: true,
      });
      // this.window?.setHiddenInMissionControl(true);
    }
  }

  open() {
    this.window ? this.window.show() : this.createWindow();
  }
  close() {
    this.window?.hide();
  }
}

windowManager.setMainWindowManager(new MainWindow());
